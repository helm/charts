rbac:
  # rbac.create -- Create and use RBAC resources
  create: true

  # rbac.pspEnabled -- Create PodSecurityPolicy (with `rbac.create`, grant roles permissions as well)
  pspEnabled: true

  # rbac.pspUseAppArmor -- Enforce AppArmor in created PodSecurityPolicy (requires `rbac.pspEnabled`)
  pspUseAppArmor: true

  # rbac.namespaced -- Creates Role and Rolebinding instead of the default ClusterRole and ClusteRoleBindings for the grafana instance
  namespaced: false

serviceAccount:
  # serviceAccount.create -- Create service account
  create: true

  # serviceAccount.name -- (string) Service account name to use, when empty will be set to created account if `serviceAccount.create` is set else to `default`
  name:

  # serviceAccount.nameTest -- (string) Service account name to use for test, when empty will be set to created account if `serviceAccount.create` is set else to `default`
  nameTest:

# replicas -- Number of nodes
replicas: 1

## See `kubectl explain deployment.spec.strategy` for more
## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
# deploymentStrategy -- Deployment strategy
deploymentStrategy:
  type: RollingUpdate

# readinessProbe -- Readiness Probe
readinessProbe:
  httpGet:
    path: /api/health
    port: 3000

# livenessProbe -- Liveness Probe
livenessProbe:
  httpGet:
    path: /api/health
    port: 3000
  initialDelaySeconds: 60
  timeoutSeconds: 30
  failureThreshold: 10

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName: "default-scheduler"

image:
  # image.repository -- Image repository
  repository: grafana/grafana
  # image.tag -- Image tag. (`Must be >= 5.0.0`)
  tag: 6.2.5
  # image.pullPolicy -- Image pull policy
  pullPolicy: IfNotPresent

  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ##
  # pullSecrets:
  #   - myRegistrKeySecretName
  # image.pullSecrets -- Image pull secrets
  pullSecrets: []

testFramework:
  # testFramework.image -- `test-framework` image repository.
  image: "dduportal/bats"

  # testFramework.tag -- `test-framework` image tag.
  tag: "0.4.0"
  securityContext: {}

securityContext:
  runAsUser: 472
  fsGroup: 472


# extraConfigmapMounts -- Additional grafana server configMap volume mounts
extraConfigmapMounts: []
  # - name: certs-configmap
  #   mountPath: /etc/grafana/ssl/
  #   configMap: certs-configmap
  #   readOnly: true


# extraEmptyDirMounts -- Additional grafana server emptyDir volume mounts
extraEmptyDirMounts: []
  # - name: provisioning-notifiers
  #   mountPath: /etc/grafana/provisioning/notifiers


# priorityClassName -- (string) Name of Priority Class to assign pods
priorityClassName:

downloadDashboardsImage:
  repository: appropriate/curl
  tag: latest
  pullPolicy: IfNotPresent

# downloadDashboards.env -- Environment variables to be passed to the `download-dashboards` container
downloadDashboards:
  env: {}

# podAnnotations -- Pod annotations
podAnnotations: {}

# annotations -- Deployment annotations
annotations: {}

## Expose the grafana service to be accessed from outside the cluster (LoadBalancer service).
## or access it from within the cluster (ClusterIP service). Set the service type and the port to serve it.
## ref: http://kubernetes.io/docs/user-guide/services/
##
service:
  # service.type -- Kubernetes service type
  type: ClusterIP

  # service.port -- Kubernetes port where service is exposed
  port: 80

  # service.targetPort -- internal service is port (4181 To be used with a proxy extraContainer)
  targetPort: 3000

  # service.annotations -- Service annotations
  annotations: {}

  # service.labels -- Custom labels
  labels: {}

ingress:

  # ingress.enabled -- Enables Ingress
  enabled: false

  # ingress.annotations -- Ingress annotations
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

  # ingress.labels -- Custom labels
  labels: {}

  # ingress.path -- Ingress accepted path
  path: /

  # ingress.hosts -- Ingress accepted hostnames
  hosts:
    - chart-example.local

  # ingress.tls -- Ingress TLS configuration
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# resources -- CPU/Memory resource requests/limits
resources: {}
#  limits:
#    cpu: 100m
#    memory: 128Mi
#  requests:
#    cpu: 100m
#    memory: 128Mi

# nodeSelector -- Node labels for pod assignment
## ref: https://kubernetes.io/docs/user-guide/node-selection/
nodeSelector: {}

# tolerations -- Toleration labels for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
tolerations: []

# affinity -- Affinity settings for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
affinity: {}

# extraInitContainers -- Init containers to add to the grafana pod
extraInitContainers: []

# extraContainers -- Sidecar containers to add to the grafana pod. This is meant to allow adding an authentication proxy to a grafana pod
extraContainers: |
# - name: proxy
#   image: quay.io/gambol99/keycloak-proxy:latest
#   args:
#   - -provider=github
#   - -client-id=
#   - -client-secret=
#   - -github-org=<ORG_NAME>
#   - -email-domain=*
#   - -cookie-secret=
#   - -http-address=http://0.0.0.0:4181
#   - -upstream-url=http://127.0.0.1:3000
#   ports:
#     - name: proxy-web
#       containerPort: 4181

## Enable persistence using Persistent Volume Claims
## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  # persistence.enabled -- Use persistent volume to store data
  enabled: false

  # persistence.storageClassName -- (string) Type of persistent volume claim
  storageClassName:

  # persistence.accessModes -- Persistence access modes
  accessModes:
    - ReadWriteOnce

  # persistence.size -- Size of persistent volume claim
  size: 10Gi

  # persistence.annotations -- PersistentVolumeClaim annotations
  annotations: {}

  # persistence.finalizers -- PersistentVolumeClaim finalizers
  finalizers:
    - kubernetes.io/pvc-protection

  # persistence.subPath -- Mount a sub dir of the persistent volume
  subPath: ""

  # persistence.existingClaim -- (string) Use an existing PVC to persist data
  existingClaim:

initChownData:
  # initChownData.enabled -- If false, don't reset data ownership at startup
  enabled: true

  ## initChownData container image
  ##
  image:
    # initChownData.image.repository -- init-chown-data container image repository
    repository: busybox

    # initChownData.image.tag -- init-chown-data container image tag
    tag: "1.30"

    # initChownData.image.pullPolicy -- init-chown-data container image pull policy
    pullPolicy: IfNotPresent

  # initChownData.resources -- init-chown-data pod resource requests & limits
  ## Ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources: {}
  #  limits:
  #    cpu: 100m
  #    memory: 128Mi
  #  requests:
  #    cpu: 100m
  #    memory: 128Mi


# Administrator credentials when not using an existing secret (see below)
adminUser: admin
# adminPassword: strongpassword

# Use an existing secret for the admin user.
admin:
  # admin.existingSecret -- The name of an existing secret containing the admin credentials.
  existingSecret: ""

  # admin.userKey -- The key in the existing admin secret containing the username.
  userKey: admin-user

  # admin.passwordKey -- The key in the existing admin secret containing the password.
  passwordKey: admin-password

## Define command to be executed at startup by grafana container
## Needed if using `vault-env` to manage secrets (ref: https://banzaicloud.com/blog/inject-secrets-into-pods-vault/)
## Default is "run.sh" as defined in grafana's Dockerfile
# command -- Define command to be executed by grafana container at startup
command: []

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName -- (string) Name of the k8s scheduler (other than default)
schedulerName:

# env -- Extra environment variables will be passed onto deployment pods
env: {}

# envFromSecret -- Name of a Kubenretes secret (must be manually created in the same namespace) containing values to be added to the environment
envFromSecret: ""

# extraSecretMounts -- Additional grafana server secret mounts. Secrets must be manually created in the namespace.
extraSecretMounts: []
  # - name: secret-files
  #   mountPath: /etc/secrets
  #   secretName: grafana-secret-files
  #   readOnly: true

# extraVolumeMounts -- Additional grafana server volume mounts
extraVolumeMounts: []
  # - name: extra-volume
  #   mountPath: /mnt/volume
  #   readOnly: true
  #   existingClaim: volume-claim

# plugins -- Plugins to be loaded along with Grafana
plugins: []
  # - digrich-bubblechart-panel
  # - grafana-clock-panel

# datasources -- Configure grafana datasources (passed through tpl)
## ref: http://docs.grafana.org/administration/provisioning/#datasources
datasources: {}
#  datasources.yaml:
#    apiVersion: 1
#    datasources:
#    - name: Prometheus
#      type: prometheus
#      url: http://prometheus-prometheus-server
#      access: proxy
#      isDefault: true

# notifiers -- Configure grafana notifiers
## ref: http://docs.grafana.org/administration/provisioning/#alert-notification-channels
notifiers: {}
#  notifiers.yaml:
#    notifiers:
#    - name: email-notifier
#      type: email
#      uid: email1
#      # either:
#      org_id: 1
#      # or
#      org_name: Main Org.
#      is_default: true
#      settings:
#        addresses: an_email_address@example.com
#    delete_notifiers:

# dashboardProviders -- Configure grafana dashboard providers. `path` must be /var/lib/grafana/dashboards/<provider_name>
## ref: http://docs.grafana.org/administration/provisioning/#dashboards
dashboardProviders: {}
#  dashboardproviders.yaml:
#    apiVersion: 1
#    providers:
#    - name: 'default'
#      orgId: 1
#      folder: ''
#      type: file
#      disableDeletion: false
#      editable: true
#      options:
#        path: /var/lib/grafana/dashboards/default

# dashboards -- Dashboards per provider, use provider name as key
## NOTE: To use dashboards you must also enable/configure dashboardProviders
## ref: https://grafana.com/dashboards
dashboards: {}
  # default:
  #   some-dashboard:
  #     json: |
  #       $RAW_JSON
  #   custom-dashboard:
  #     file: dashboards/custom-dashboard.json
  #   prometheus-stats:
  #     gnetId: 2
  #     revision: 2
  #     datasource: Prometheus
  #   local-dashboard:
  #     url: https://example.com/repository/test.json
  #   local-dashboard-base64:
  #     url: https://example.com/repository/test-b64.json
  #     b64content: true

# dashboardsConfigMaps -- Reference to external ConfigMap per provider. Use provider name as key and ConfiMap name as value
##
## A provider dashboards must be defined either by external ConfigMaps or in values.yaml, not in both.
## ConfigMap data example:
##
## data:
##   example-dashboard.json: |
##     RAW_JSON
##
dashboardsConfigMaps: {}
#  default: ""

## Grafana's primary configuration
## NOTE: values in map will be converted to ini format
## ref: http://docs.grafana.org/installation/configuration/
##
grafana.ini:
  paths:
    data: /var/lib/grafana/data
    logs: /var/log/grafana
    plugins: /var/lib/grafana/plugins
    provisioning: /etc/grafana/provisioning
  analytics:
    check_for_updates: true
  log:
    mode: console
  grafana_net:
    url: https://grafana.net
## LDAP Authentication can be enabled with the following values on grafana.ini
## NOTE: Grafana will fail to start if the value for ldap.toml is invalid
  # auth.ldap:
  #   enabled: true
  #   allow_sign_up: true
  #   config_file: /etc/grafana/ldap.toml

## Grafana's LDAP configuration
## Templated by the template in _helpers.tpl
## NOTE: To enable the grafana.ini must be configured with auth.ldap.enabled
## ref: http://docs.grafana.org/installation/configuration/#auth-ldap
## ref: http://docs.grafana.org/installation/ldap/#configuration
ldap:
  # ldap.existingSecret -- The name of an existing secret containing the `ldap.toml` file, this must have the key `ldap-toml`.
  existingSecret: ""

  # ldap.config   -- Grafana's LDAP configuration
  config: ""
  # config: |-
  #   verbose_logging = true

  #   [[servers]]
  #   host = "my-ldap-server"
  #   port = 636
  #   use_ssl = true
  #   start_tls = false
  #   ssl_skip_verify = false
  #   bind_dn = "uid=%s,ou=users,dc=myorg,dc=com"

## Grafana's SMTP configuration
## NOTE: To enable, grafana.ini must be configured with smtp.enabled
## ref: http://docs.grafana.org/installation/configuration/#smtp
smtp:
  # smtp.existingSecret -- The name of an existing secret containing the SMTP credentials.
  existingSecret: ""

  # smtp.userKey -- The key in the existing SMTP secret containing the username.
  userKey: "user"

  # smtp.passwordKey -- The key in the existing SMTP secret containing the password.
  passwordKey: "password"

## Sidecars that collect the configmaps with specified label and stores the included files them into the respective folders
## Requires at least Grafana 5 to work and can't be used together with parameters dashboardProviders, datasources and dashboards
sidecar:
  # sidecar.image -- Sidecar image
  image: kiwigrid/k8s-sidecar:0.0.18

  # sidecar.imagePullPolicy -- Sidecar image pull policy
  imagePullPolicy: IfNotPresent

  # sidecar.resources -- Sidecar resources
  resources: {}
#   limits:
#     cpu: 100m
#     memory: 100Mi
#   requests:
#     cpu: 50m
#     memory: 50Mi

  # sidecar.skipTlsVerify -- Set to true to skip tls verification for kube api calls
  skipTlsVerify: false

  dashboards:
    # sidecar.dashboards.enabled -- Enabled the cluster wide search for dashboards and adds/updates/deletes them in grafana
    enabled: false

    # label that the configmaps with dashboards are marked with
    # sidecar.dashboards.label -- Label that config maps with dashboards should have to be added
    label: grafana_dashboard

    # sidecar.dashboards.folder -- Folder in the pod that should hold the collected dashboards (unless `sidecar.dashboards.defaultFolderName` is set). This path will be mounted.
    folder: /tmp/dashboards

    # sidecar.dashboards.defaultFolderName -- The default folder name, it will create a subfolder under the `sidecar.dashboards.folder` and put dashboards in there instead
    defaultFolderName: null

    # sidecar.dashboards.searchNamespace -- If specified, the sidecar will search for dashboard config-maps inside this namespace. Otherwise the namespace in which the sidecar is running will be used. It's also possible to specify ALL to search in all namespaces
    searchNamespace: null

    # provider configuration that lets grafana manage the dashboards
    provider:
      name: sidecarProvider

      # sidecar.dashboards.provider.orgid -- Id of the organisation, to which the dashboards should be added
      orgid: 1

      # sidecar.dashboards.provider.folder -- Logical folder in which grafana groups dashboards
      folder: ''

      # sidecar.dashboards.provider.type -- Provider type
      type: file

      # sidecar.dashboards.provider.disableDelete -- Activate to avoid the deletion of imported dashboards
      disableDelete: false

  datasources:
    # sidecar.datasources.enabled -- Enabled the cluster wide search for datasources and adds/updates/deletes them in grafana
    enabled: false

    # sidecar.datasources.label -- Label that config maps with datasources should have to be added
    label: grafana_datasource

    # sidecar.datasources.searchNamespace -- (string) If specified, the sidecar will search for datasources config-maps inside this namespace. Otherwise the namespace in which the sidecar is running will be used. It's also possible to specify ALL to search in all namespaces
    searchNamespace: null
