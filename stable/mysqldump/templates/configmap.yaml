apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "mysqldump.fullname" . }}
  labels:
    app: {{ template "mysqldump.name" . }}
    chart: {{ template "mysqldump.chart" . }}
    release: "{{ .Release.Name }}"
    heritage: "{{ .Release.Service }}"
data:
  MYSQL_HOST: {{ .Values.mysql.host | quote }}
  MYSQL_USERNAME: {{ .Values.mysql.username | quote }}
  MYSQL_PORT: {{ .Values.mysql.port | quote }}
  MYSQL_OPTS: {{ .Values.options | quote }}
  KEEP_DAYS: {{ .Values.housekeeping.keepDays | quote }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "mysqldump.fullname" . }}-script
  labels:
    app: {{ template "mysqldump.name" . }}
    chart: {{ template "mysqldump.chart" . }}
    release: "{{ .Release.Name }}"
    heritage: "{{ .Release.Service }}"
data:
  backup.sh: |-
    #!/bin/sh
    #
    # mysql backup script
    #
    {{ if .Values.debug }}
    set -ex
    {{ end }}
    BACKUP_DIR="/backup"
    TIMESTAMP="$(date +%Y%m%d%H%M%S)"

    echo "test mysql connection"
    if [ -z "$(mysql -h ${MYSQL_HOST} -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} -B -N -e 'SHOW DATABASES;')" ]; then
      echo "mysql connection failed! exiting..."
      exit 1
    fi

    echo "started" > ${BACKUP_DIR}/${TIMESTAMP}.state

    {{- if (.Values.persistence.enabled) or (.Values.persistentVolumeClaim) }}
    {{ if .Values.housekeeping.enabled }}
    echo "delete old backups"
    find ${BACKUP_DIR} -maxdepth 1 -mtime +${KEEP_DAYS} -regex "^${BACKUP_DIR}/[0-9]*_.*\.sql\.gz$" -type f -exec rm {} \;
    {{ end -}}

    {{ if and (.Values.mysql.db) (eq .Values.allDatabases.enabled false) }}
    MYSQL_DB="{{ .Values.mysql.db }}"
    echo "Backing up single db ${MYSQL_DB}"
    mysqldump ${MYSQL_OPTS} -h ${MYSQL_HOST} -P ${MYSQL_PORT} -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} ${MYSQL_DB} | gzip > ${BACKUP_DIR}/${TIMESTAMP}_${MYSQL_DB}.sql.gz

    {{ else if and (.Values.allDatabases.enabled) (eq .Values.allDatabases.SingleSqlFile false)}}
    for MYSQL_DB in $(mysql -h "${MYSQL_HOST}" -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} -B -N -e "SHOW DATABASES;"|egrep -v '^(information|performance)_schema$'); do
      echo "Backing up db ${MYSQL_DB}"
      mysqldump ${MYSQL_OPTS} -h ${MYSQL_HOST} -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} ${MYSQL_DB} | gzip > ${BACKUP_DIR}/${TIMESTAMP}_${MYSQL_DB}.sql.gz
      rc=$?
    done

    {{ else if and (.Values.allDatabases.enabled) (.Values.allDatabases.SingleSqlFile) }}
    echo "Backing up all databases"
    MYSQL_DB="alldatabases"
    mysqldump ${MYSQL_OPTS} -h ${MYSQL_HOST} -P ${MYSQL_PORT} -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} --all-databases | gzip > ${BACKUP_DIR}/${TIMESTAMP}_${MYSQL_DB}.sql.gz
    rc=$?
    {{- end -}}

    {{- if (.Values.upload.googlestoragebucket.enabled) or (.Values.upload.ssh.enabled) -}}
    for FILE in $(find ${BACKUP_DIR} -maxdepth 1 -regex "^${BACKUP_DIR}/${TIMESTAMP}_.*\.sql\.gz$" -type f | sed -e 's#.*/##g'); do
      {{ if .Values.upload.ssh.enabled -}}
      echo "upload ${FILE} via ssh"
      ssh -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=/dev/null {{ .Values.upload.ssh.user }}@{{ .Values.upload.ssh.host }} "cat > {{ .Values.upload.ssh.dir }}/${FILE}" < ${BACKUP_DIR}/${FILE}
      rcu=$?
      {{ end }}
      {{- if .Values.upload.googlestoragebucket.enabled }}
      echo "upload ${FILE} to google storage bucket"
      gcloud auth activate-service-account --key-file /root/gcloud/keyfile.json
      gsutil cp ${BACKUP_DIR}/${FILE} {{ .Values.upload.googlestoragebucket.bucketname }}/${FILE}
      rcu=$?
      {{ end }}
      if [ "$rcu" != "0" ]; then
        echo "upload failed"
        exit 1
      fi
      {{ end }}
    done

    {{- else }}
    mysqldump ${MYSQL_OPTS} -h ${MYSQL_HOST} -P ${MYSQL_PORT} -u ${MYSQL_USERNAME}{{ if .Values.mysql.password }} -p${MYSQL_PASSWORD}{{ end }} --all-databases
    rc=$?
    {{- end }}
    if [ "$rc" != "0" ]; then
      echo "backup failed"
      exit 1
    fi
    {{ if .Values.debug }}
    ls -alh ${BACKUP_DIR}
    {{ end }}
    echo "complete" > ${BACKUP_DIR}/${TIMESTAMP}.state
    echo "Backup successful! :-)"
