# Default values for graphite.

image:
  repository: graphiteapp/graphite-statsd
  tag: 1.1.3
  pullPolicy: IfNotPresent

service:
  type: ClusterIP

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  path: /
  hosts:
    - chart-example.local
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # limits:
  #  cpu: 100m
  #  memory: 512Mi
  # requests:
  #  cpu: 100m
  #  memory: 512Mi

nodeSelector: {}

tolerations: []

affinity: {}

configMaps:
  aggregation-rules.conf: |-
    # The form of each line in this file should be as follows:
    #
    #   output_template (frequency) = method input_pattern
    #
    # This will capture any received metrics that match 'input_pattern'
    # for calculating an aggregate metric. The calculation will occur
    # every 'frequency' seconds and the 'method' can specify 'sum' or
    # 'avg'. The name of the aggregate metric will be derived from
    # 'output_template' filling in any captured fields from 'input_pattern'.
    #
    # For example, if you're metric naming scheme is:
    #
    #   <env>.applications.<app>.<server>.<metric>
    #
    # You could configure some aggregations like so:
    #
    #   <env>.applications.<app>.all.requests (60) = sum <env>.applications.<app>.*.requests
    #   <env>.applications.<app>.all.latency (60) = avg <env>.applications.<app>.*.latency
    #
    # As an example, if the following metrics are received:
    #
    #   prod.applications.apache.www01.requests
    #   prod.applications.apache.www01.requests
    #
    # They would all go into the same aggregation buffer and after 60 seconds the
    # aggregate metric 'prod.applications.apache.all.requests' would be calculated
    # by summing their values.
    #
    # Template components such as <env> will match everything up to the next dot.
    # To match metric multiple components including the dots, use <<metric>> in the
    # input template:
    #
    #   <env>.applications.<app>.all.<app_metric> (60) = sum <env>.applications.<app>.*.<<app_metric>>
    #
    # Note that any time this file is modified, it will be re-read automatically.
  blacklist.conf: |-
    # This file takes a single regular expression per line
    # If USE_WHITELIST is set to True in carbon.conf, any metrics received which
    # match one of these expressions will be dropped
    # This file is reloaded automatically when changes are made
    ^some\.noisy\.metric\.prefix\..*
  carbon.amqp.conf: |-
    # This is a configuration file with AMQP enabled

    [cache]
    LOCAL_DATA_DIR =

    # Specify the user to drop privileges to
    # If this is blank carbon runs as the user that invokes it
    # This user must have write access to the local data directory
    USER =

    # Limit the size of the cache to avoid swapping or becoming CPU bound.
    # Sorts and serving cache queries gets more expensive as the cache grows.
    # Use the value "inf" (infinity) for an unlimited cache size.
    MAX_CACHE_SIZE = inf

    # Limits the number of whisper update_many() calls per second, which effectively
    # means the number of write requests sent to the disk. This is intended to
    # prevent over-utilizing the disk and thus starving the rest of the system.
    # When the rate of required updates exceeds this, then carbon's caching will
    # take effect and increase the overall throughput accordingly.
    MAX_UPDATES_PER_SECOND = 1000

    # Softly limits the number of whisper files that get created each minute.
    # Setting this value low (like at 50) is a good way to ensure your graphite
    # system will not be adversely impacted when a bunch of new metrics are
    # sent to it. The trade off is that it will take much longer for those metrics'
    # database files to all get created and thus longer until the data becomes usable.
    # Setting this value high (like "inf" for infinity) will cause graphite to create
    # the files quickly but at the risk of slowing I/O down considerably for a while.
    MAX_CREATES_PER_MINUTE = inf

    LINE_RECEIVER_INTERFACE = 0.0.0.0
    LINE_RECEIVER_PORT = 2003

    UDP_RECEIVER_INTERFACE = 0.0.0.0
    UDP_RECEIVER_PORT = 2003

    PICKLE_RECEIVER_INTERFACE = 0.0.0.0
    PICKLE_RECEIVER_PORT = 2004

    CACHE_QUERY_INTERFACE = 0.0.0.0
    CACHE_QUERY_PORT = 7002

    # Enable AMQP if you want to receve metrics using you amqp broker
    ENABLE_AMQP = True

    # Verbose means a line will be logged for every metric received
    # useful for testing
    AMQP_VERBOSE = True

    # your credentials for the amqp server
    # AMQP_USER = guest
    # AMQP_PASSWORD = guest

    # the network settings for the amqp server
    # AMQP_HOST = localhost
    # AMQP_PORT = 5672

    # if you want to include the metric name as part of the message body
    # instead of as the routing key, set this to True
    # AMQP_METRIC_NAME_IN_BODY = False

    # NOTE: you cannot run both a cache and a relay on the same server
    # with the default configuration, you have to specify a distinict
    # interfaces and ports for the listeners.

    [relay]
    LINE_RECEIVER_INTERFACE = 0.0.0.0
    LINE_RECEIVER_PORT = 2003

    PICKLE_RECEIVER_INTERFACE = 0.0.0.0
    PICKLE_RECEIVER_PORT = 2004

    CACHE_SERVERS = server1, server2, server3
    MAX_QUEUE_SIZE = 10000
  dashboard.conf: |-
    # This configuration file controls the behavior of the Dashboard UI, available
    # at http://my-graphite-server/dashboard/.
    #
    # This file must contain a [ui] section that defines values for all of the
    # following settings.
    [ui]
    default_graph_width = 400
    default_graph_height = 250
    automatic_variants = true
    refresh_interval = 60
    autocomplete_delay = 375
    merge_hover_delay = 750

    # You can set this 'default', 'white', or a custom theme name.
    # To create a custom theme, copy the dashboard-default.css file
    # to dashboard-myThemeName.css in the content/css directory and
    # modify it to your liking.
    theme = default

    [keyboard-shortcuts]
    toggle_toolbar = ctrl-z
    toggle_metrics_panel = ctrl-space
    erase_all_graphs = alt-x
    save_dashboard = alt-s
    completer_add_metrics = alt-enter
    completer_del_metrics = alt-backspace
    give_completer_focus = shift-space

    # These settings apply to the UI as a whole, all other sections in this file
    # pertain only to specific metric types.
    #
    # The dashboard presents only metrics that fall into specified naming schemes
    # defined in this file. This creates a simpler, more targetted view of the
    # data. The general form for defining a naming scheme is as follows:
    #
    #[Metric Type]
    #scheme = basis.path.<field1>.<field2>.<fieldN>
    #field1.label = Foo
    #field2.label = Bar
    #
    #
    # Where each <field> will be displayed as a dropdown box
    # in the UI and the remaining portion of the namespace
    # shown in the Metric Selector panel. The .label options set the labels
    # displayed for each dropdown.
    #
    # For example:
    #
    #[Sales]
    #scheme = sales.<channel>.<type>.<brand>
    #channel.label = Channel
    #type.label = Product Type
    #brand.label = Brand
    #
    # This defines a 'Sales' metric type that uses 3 dropdowns in the Context Selector
    # (the upper-left panel) while any deeper metrics (per-product counts or revenue, etc)
    # will be available in the Metric Selector (upper-right panel).
  graphite.wsgi.example: |-
    import sys
    sys.path.append('/opt/graphite/webapp')

    from graphite.wsgi import application
  graphTemplates.conf: |-
    [default]
    background = black
    foreground = white
    majorLine = white
    minorLine = grey
    lineColors = blue,green,red,purple,brown,yellow,aqua,grey,magenta,pink,gold,rose
    fontName = Sans
    fontSize = 10
    fontBold = False
    fontItalic = False

    [noc]
    background = black
    foreground = white
    majorLine = white
    minorLine = grey
    lineColors = blue,green,red,yellow,purple,brown,aqua,grey,magenta,pink,gold,rose
    fontName = Sans
    fontSize = 10
    fontBold = False
    fontItalic = False

    [plain]
    background = white
    foreground = black
    minorLine = grey
    majorLine = rose

    [summary]
    background = black
    lineColors = #6666ff, #66ff66, #ff6666

    [alphas]
    background = white
    foreground = black
    majorLine = grey
    minorLine = rose
    lineColors = 00ff00aa,ff000077,00337799
  relay-rules.conf: |-
    # Relay destination rules for carbon-relay. Entries are scanned in order,
    # and the first pattern a metric matches will cause processing to cease after sending
    # unless `continue` is set to true
    #
    #  [name]
    #  pattern = <regex>
    #  destinations = <list of destination addresses>
    #  continue = <boolean>  # default: False
    #
    #  name: Arbitrary unique name to identify the rule
    #  pattern: Regex pattern to match against the metric name
    #  destinations: Comma-separated list of destinations.
    #    ex: 127.0.0.1, 10.1.2.3:2004, 10.1.2.4:2004:a, myserver.mydomain.com
    #  continue: Continue processing rules if this rule matches (default: False)

    # You must have exactly one section with 'default = true'
    # Note that all destinations listed must also exist in carbon.conf
    # in the DESTINATIONS setting in the [relay] section
    [default]
    default = true
    destinations = 0.0.0.0:2004
  rewrite-rules.conf: |-
    # This file defines regular expression patterns that can be used to
    # rewrite metric names in a search & replace fashion. It consists of two
    # sections, [pre] and [post]. The rules in the pre section are applied to
    # metric names as soon as they are received. The post rules are applied
    # after aggregation has taken place.
    #
    # The general form of each rule is as follows:
    #
    # regex-pattern = replacement-text
    #
    # For example:
    #
    # [post]
    # _sum$ =
    # _avg$ =
    #
    # These rules would strip off a suffix of _sum or _avg from any metric names
    # after aggregation.
  storage-aggregation.conf: |-
    # Aggregation methods for whisper files. Entries are scanned in order,
    # and first match wins. This file is scanned for changes every 60 seconds
    #
    #  [name]
    #  pattern = <regex>
    #  xFilesFactor = <float between 0 and 1>
    #  aggregationMethod = <average|sum|last|max|min>
    #
    #  name: Arbitrary unique name for the rule
    #  pattern: Regex pattern to match against the metric name
    #  xFilesFactor: Ratio of valid data points required for aggregation to the next retention to occur
    #  aggregationMethod: function to apply to data points for aggregation
    #
    [min]
    pattern = \.lower$
    xFilesFactor = 0.1
    aggregationMethod = min

    [max]
    pattern = \.upper(_\d+)?$
    xFilesFactor = 0.1
    aggregationMethod = max

    [sum]
    pattern = \.sum$
    xFilesFactor = 0
    aggregationMethod = sum

    [count]
    pattern = \.count$
    xFilesFactor = 0
    aggregationMethod = sum

    [count_legacy]
    pattern = ^stats_counts.*
    xFilesFactor = 0
    aggregationMethod = sum

    [default_average]
    pattern = .*
    xFilesFactor = 0.3
    aggregationMethod = average
  storage-schemas.conf: |-
    # Schema definitions for Whisper files. Entries are scanned in order,
    # and first match wins. This file is scanned for changes every 60 seconds.
    #
    # Definition Syntax:
    #
    #    [name]
    #    pattern = regex
    #    retentions = timePerPoint:timeToStore, timePerPoint:timeToStore, ...
    #
    # Remember: To support accurate aggregation from higher to lower resolution
    #           archives, the precision of a longer retention archive must be
    #           cleanly divisible by precision of next lower retention archive.
    #
    #           Valid:    60s:7d,300s:30d (300/60 = 5)
    #           Invalid:  180s:7d,300s:30d (300/180 = 3.333)
    #

    # Carbon's internal metrics. This entry should match what is specified in
    # CARBON_METRIC_PREFIX and CARBON_METRIC_INTERVAL settings
    [carbon]
    pattern = ^carbon\.
    retentions = 10s:6h,1m:90d

    [default_1min_for_1day]
    pattern = .*
    retentions = 10s:6h,1m:6d,10m:1800d
  whitelist.conf: |-
    # This file takes a single regular expression per line
    # If USE_WHITELIST is set to True in carbon.conf, only metrics received which
    # match one of these expressions will be persisted. If this file is empty or
    # missing, all metrics will pass through.
    # This file is reloaded automatically when changes are made
    .*
